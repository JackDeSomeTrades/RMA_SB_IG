task_config:
  seed: 43

  env:
    num_envs: 50
    num_observations: 40
    num_privileged_obs: None # if not None a privilege_obs_buf will be returned by step() (critic obs for assymetric training). None is returned otherwise
    num_actions: 8
    env_spacing: 3. 
    send_timeouts: True # send time out information to the algorithm
    episode_length_s : 30
    # episode length in seconds
  terrain:
    mesh_type: 'none' # "heightfield" # none, plane, heightfield or trimesh
    horizontal_scale: 0.1 # [m]
    vertical_scale: 0.005 # [m]
    border_size: 3 # [m]
    static_friction: 0.5
    dynamic_friction: 0.5
    restitution: 0.
    num_rows: 10 # number of terrain rows (levels)
    num_cols: 20 # number of terrain cols (types)

  init_state:
    rot: [ 0.0, 0.0, 0.0, 0.0 ] # x,y,z,w [quat]
    lin_vel: [ 0.0, 0.0, 0.0 ]  # x,y,z [m/s]
    ang_vel: [ 0.0, 0.0, 0.0 ]  # x,y,z [rad/s]
    pos: [ 0.0, 0.0, 0.0 ]  # x,y,z [m]
    angle : 0.0
    default_joint_init: { #: target angles [rad] when action: 0.0
      'vertical_axis' : 1.0,
      'gripper_rotate' : -3.14,
      'gripper_base_x' : 0.3,
      'gripper_y_left' : 0.25,
      'conveyor_belt_left' : 0.0,
      'gripper_y_right' : 0.25,
      'conveyor_belt_right' : 0.01,
      'conveyor_right_to_belt' : 0.0,
      'conveyor_left_to_belt' : 0.0
    }

  asset:
    file: '{ROOT_DIR}/resources/robots/soto_2/soto_gripper.urdf'
    name: "soto_gripper" #actor name
    foot_name: "conveyor_belt" # name of the feet bodies, used to index body state and contact force tensors
    penalize_contacts_on: [] # important to provide the sidebar links all around the end effector
    terminate_after_contacts_on: ["base_footprint", "gripper_base_x_link", "gripper_base_link","vertical_axis_link"]
    self_collisions: 0  # 1 to disable, 0 to enable...bitwise filter
    disable_gravity: True
    collapse_fixed_joints: True # merge bodies connected by fixed joints. Specific fixed joints can be kept by adding " <... dont_collapse="true">
    fix_base_link: True # so the base shouldn't be allowed to move no matter what 
    default_dof_drive_mode: 3 # see GymDofDriveModeFlags (0 is none, 1 is pos tgt, 2 is vel tgt, 3 effort)
    replace_cylinder_with_capsule: True
    flip_visual_attachments: False # imp: this is the flag that was giving us issues.
    override_inertia : False #overide inertia properties (might be wrong)
    override_com : False #overide inertia properties (might be wrong)
    restitution : 0.0
    angular_damping: 0.
    linear_damping: 0.
    max_angular_velocity: 1000.
    max_linear_velocity: 1000.
    armature: 0.
    thickness: 0.01


  distance_sensor :
    fov : 1 #degrés
    near_plane : 0.025
    far_plane : 1.5
    use_collision_geometry : True
    enable_tensors : True
    height : 1
    width : 1

  control:
    # PD Drive parameters:
    control_type: 'P' # P: position, V: velocity, T: torques
    stiffness: { 'joint': 20., 'conveyor_left_to_belt' : 10}  # [N/m]
    damping: { 'joint': 1.0,'conveyor_left_to_belt' : 1.0}  # [N*m*s/rad]
    # action scale: target angle: actionScale * action + defaultAngle
    action_scale: 1.0
    # decimation: Number of control action updates @ sim DT per policy DT
    decimation: 2

  commands:
    curriculum: False
    max_curriculum: 1.
    num_commands: 1 # default: pos_x, lin_vel_y, ang_vel_yaw, heading (in heading mode ang_vel_yaw is recomputed from heading error)
    resampling_time: 30. # time before command are changed[s]
    heading_command: False # if true: compute ang vel command from heading error. If false, set to 0.
    command_angle: 1.57079
    ranges:
      pos_x : [0.3,0.6]
      lin_vel_x: [ 0.2, 0.35 ] # min max [m/s]
      angle : [0.0, 90.0]


  domain_rand:
    randomize_friction : True
    friction_static_range : [0.7,0.9]
    randomize_base_mass: True
    mass_box: [0.5, 3.0]
    length_box : [0.40,0.42]
    width_box : [0.6,0.62]
    height_box : [0.1,0.1]
    randomize_com : True
    com_distribution_range : [-0.1,0.1]
    push_robot : False
    push_interval : [0.1,0.3]

  normalization:
    clip_observations: 100.
    clip_actions: 100.
    obs_scales:
      lin_vel: 2.0
      dof_vel: 1.0
      dof_pos: 1.0
      action: 1.0

  rewards:
    only_positive_rewards: False # if true negative total rewards are clipped at zero (avoids early termination problems)
    tracking_angle: 0.5 # tracking reward: exp(-error^2/sigma)
    tracking_distance : 0.5
    tracking_arms : 0.5
    velocity : 0.5
    soft_dof_vel_limit: 1.
    soft_torque_limit: 1.
    max_contact_force: 100. # forces above this value are penalized
    soft_dof_pos_limit: 0.9 # percentage of urdf limits, values above this limit are penalized
    scales:
      turn: 10.
      ecartement: 2.
      termination: 20.
      #distance_min : 0.1


  noise:
    add_noise: True
    noise_level: 1.0 # scales other values
    noise_scales:
       dof_pos: 0.01
       dof_vel: 0.01
       lin_vel: 0.01
       ang_vel: 0.01
       gravity: 0.01
       action : 0.01
       distance_measurements: 0.01
       motor_strength: 0.01

  sim_param:
    dt: 0.01
    substeps: 2
    gravity: [ 0., 0. ,-9.81 ]  # [m/s^2]
    up_axis: 1  # 0 is y, 1 is z
    use_gpu: True
    physx:
      num_threads: 0
      solver_type: 0  # 0: pgs, 1: tgs
      num_position_iterations: 4
      num_velocity_iterations: 0
      bounce_threshold_velocity: 0.5 #0.5 [m/s]
      max_depenetration_velocity: 100
      contact_collection: 1 # 0: never, 1: last sub-step, 2: all sub-steps (default=2)


rl_config:
  device: 'cuda:0'
#  batchsize_p1: 80000
  num_iterations_p1: 15000
  n_timesteps: 1000000
  normalize: True
  logging:
    dir: '{ROOT_DIR}/logs/'
    run_name : 'PPO_3__soto'
  ppo:
    n_steps: 25 # TODO: adapt to your setting
    batch_size: 1250 # TODO: adapt to your setting
#    n_epochs: 5
    gae_lambda: 0.95
    gamma: 0.99
    n_epochs: 10
    ent_coef: 0.01
    lr: 1e-3
    clip_range: 0.2
    max_grad_norm: 1.0
    vf_coef: 1.0
    # use_sde: False
    # sde_sample_freq: 4

arch_config:
  device: 'cuda:0'
  state_action_horizon: 50
  encoder:
    encoded_extrinsic_size: 5 #size une fois passé dans l'encoder (ne devrait pas changer)
    action_space_size: 8 #ok
    state_space_size: 22 #intrisic parameters
    env_size: 5 # define the input of rma ->extrinsic
  adaptation:
    epochs: 500
    optimizer: 'Adam'
    lr: 0.5e-3
    loss: 'mse'

